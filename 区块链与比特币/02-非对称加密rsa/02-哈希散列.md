# 一、单向散列函数

```go
"单向散列函数 --- 获取消息的指纹"
```

> 在刑事侦查中，侦查员会用到指纹。通过将某个特定人物的指纹与犯罪现场遗留的指纹进行对比，就能够知道该人物与案件是否存在关联。
>
> 针对计算机所处理的消息，有时候我们也需要用到“指纹"。当需要比较两条消息是否一致时，我们不必直接对比消息本身的内容，只要对比它们的“指纹”就可以了。
>
> 本章中，我们将学习单向散列函数的相关知识。使用单向散列函数就可以获取消息的“指纹”，通过对比 "指纹"，就能够知道两条消息是否一致。
>
> 下面，我们会先简单介绍一下单向散列函数，并给大家展示具体的例子。然后我们将详细介绍现在使用非常广泛的SHA-I单向散列函数。



## 1. 什么是单向散列函数

> 单向散列函数（one-wayftnction）有一个输人和一个输出，其中输人称为消息（message），输出称为散列值（hashvalue）。单向散列函数可以根据消息的内容计算出散列值，而散列值就可以被用来检查消息的完整性。

![1538733101252](https://ws4.sinaimg.cn/large/006tNc79ly1fyzcicixjej3044073dfr.jpg)

> 这里的消息不一定是人类能够读懂的文字，也可以是图像文件或者声音文件。单向散列函数不需要知道消息实际代表的含义。无论任何消息，单向散列函数都会将它作为单纯的比特序列来处理，即根据比特序列计算出散列值。
>
> 散列值的长度和消息的长度无关。无论消息是1比特，还是100MB，甚至是IOOGB，单向散列函数都会计算出固定长度的散列值。以SHA-I单向散列函数为例，它所计算出的散列值的长度永远是160比特（20字节）。

![1538733147410](https://ws4.sinaimg.cn/large/006tNc79ly1fyzcic3vaij30hh09kjsj.jpg)

## 2. 关于术语

> 单向散列函数的相关术语有很多变体，不同参考资料中所使用的术语也不同，下面我们就介绍其中的儿个。
>
> 单向散列函数也称为**消息摘要函数**（message digest function）、**哈希函数**或者**杂凑函数**。
>
> 输入单向散列函数的消息也称为**原像**（pre-image）。
>
> 单向散列函数输出的散列值也称为**消息摘要**（message digest）或者**指纹**（fingerprint）。
>
> **完整性**也称为一致性。
>
> 顺便说一句，单向散列函数中的“散列”的英文"hash一词，原意是古法语中的“斧子”，后来被引申为“剁碎的肉末"，也许是用斧子一通乱剁再搅在一起的那种感觉吧。单向散列函数的作用，实际上就是将很长的消息剁碎，然后再混合成固定长度的散列值。

# 二、单向散列函数的性质

> 通过使用单向散列函数，即便是确认几百MB大小的文件的完整性，也只要对比很短的散列值就可以了。那么，单向散列函数必须具备怎样的性质呢？我们来整理一下。

## 1. 根据任意长度的消息计算出固定长度的散列值

> 首先，单向散列函数的输人必须能够是任意长度的消息。
>
> 其次，无论输人多长的消息，单向散列函数必须都能够生成长度很短的散列值，如果消息越长生成的散列值也越长的话就不好用了。从使用方便的角度来看，散列值的长度最好是短且固定的。

## 2. 能够快速计算出散列值

> 计算散列值所花费的时间必须要短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的时间内完成计算就没有意义了。

## 3. 消息不同散列值也不同

> 为了能够确认完整性，消息中哪怕只有1比特的改变，也必须有很高的概率产生不同的散列值。
>
> 如果单向散列函数计算出的散列值没有发生变化，那么消息很容易就会被篡改，这个单向散列函数也就无法被用于完整性的检查。**两个不同的消息产生同一个散列值的情况称为碰撞（collision）**。如果要将单向散列函数用于完整性的检查，则需要确保在事实上不可能被人为地发现碰撞。

![1538733187999](https://ws3.sinaimg.cn/large/006tNc79ly1fyzcibc6gvj30hq0em77i.jpg)

> **难以发现碰撞的性质称为抗碰撞性（collisionresistance）**。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。
>
> 强抗碰撞性，是指要找到散列值相同的两条不同的消息是非常困难的这一性质。在这里，散列值可以是任意值。密码技术中的单向散列函数必须具备强抗碰撞性。

![1538733240065](https://ws1.sinaimg.cn/large/006tNc79ly1fyzcid4961j309p0bhglz.jpg)

- **具备单向性**

  > 单向散列函数必须具备单向性（one-way）。单向性指的是无法通过散列值反算出消息的性质。根据消息计算散列值可以很容易，但这条单行路是无法反过来走的。

  ![1538733271733](https://ws1.sinaimg.cn/large/006tNc79ly1fyzcidhcwdj30fj08g3yq.jpg)

  > 正如同将玻璃砸得粉碎很容易，但却无法将碎片还原成完整的玻璃一样，根据消息计算出散列值很容易，但根据散列值却无法反算出消息。
  >
  > 在这里需要注意的一点是，尽管单向散列函数所产生的散列值是和原来的消息完全不同的比特序列，但是**单向散列函数并不是一种加密，因此无法通过解密将散列值还原为原来的消息**。

# 三、单向散列函数的实际应用

> 下面我们来看一下实际应用单向散列函数的例子。

## 1. 检测软件是否被篡改

> 我们可以使用单向散列函数来确认自己下载的软件是否被篡改。
>
> 很多软件，尤其是安全相关的软件都会把通过单向散列函数计算出的散列值公布在自己的官方网站上。用户在下载到软件之后，可以自行计算散列值，然后与官方网站上公布的散列值进行对比。通过散列值，用户可以确认自己所下载到的文件与软件作者所提供的文件是否一致。
>
> 这样的方法，在可以通过多种途径得到软件的情况下非常有用。为了减轻服务器的压力，很多软件作者都会借助多个网站（镜像站点）来发布软件，在这种情况下，单向散列函数就会在检测软件是否被篡改方面发挥重要作用。

![1538733447564](https://ws1.sinaimg.cn/large/006tNc79ly1fyzcibowbfj30ha0giwfq.jpg)

验证一下以太坊这个exe文件是否被篡改

==linux : sha256sum 文件名字==

![image-20190110225102871](https://ws2.sinaimg.cn/large/006tNc79ly1fz1vlj25bzj31r50u0ts8.jpg)



## 1. 消息认证码

> 使用单向散列函数可以构造消息认证码。
>
> 消息认证码是将“发送者和接收者之间的共享密钥”和“消息，进行混合后计算出的散列值。使用消息认证码可以检测并防止通信过程中的错误、篡改以及伪装。
>
> 消息认证码在SSL/TLS中也得到了运用，关于SSL/TLS我们将后边章节中介绍。

## 2. 数字签名

==私钥对文件签名时，并不会对文件本身做签名，而是对这个文件的哈希值进行签名==

> 在进行数字签名时也会使用单向散列函数。
>
> 数字签名是现实社会中的签名（sign）和盖章这样的行为在数字世界中的实现。数字签名的处理过程非常耗时，因此一般不会对整个消息内容直接施加数字签名，而是先通过单向散列函数计算出消息的散列值，然后再对这个散列值施加数字签名。



## 3. 伪随机数生成器

> 使用单向散列函数可以构造伪随机数生成器。
>
> 密码技术中所使用的随机数需要具备“事实上不可能根据过去的随机数列预测未来的随机数列”这样的性质。为了保证不可预测性，可以利用单向散列函数的单向性。



## 4. 一次性口令

> 使用单向散列函数可以构造一次性口令（one-time password）。
>
> 一次性口令经常被用于服务器对客户端的合法性认证。在这种方式中，通过使用单向散列函数可以保证口令只在通信链路上传送一次（one-time），因此即使窃听者窃取了口令，也无法使用。



## 5. 密码存储

> 网站数据库中，对密码的存储并不是密码的明文，而是密码的哈希值，
>
> 每次登录时，会对密码进行哈希处理，然后与数据库对比。
>
> 即使数据库被盗，黑客也无法拿到用户的密码，保证用户账户安全



# 四、常用的单向散列函数

## 1. MD4、MD5

> MD4是由Rivest于1990年设计的单向散列函数，能够产生128比特的散列值（RFC1186，修订版RFC1320）。不过，随着Dobbertin提出寻找MD4散列碰撞的方法，因此现在它已经不安全了。
>
> MD5是由Rwest于1991年设计的单项散列函数，能够产生128比特的散列值（RFC1321）。
>
> MD5的强抗碰撞性已经被攻破，也就是说，现在已经能够产生具备相同散列值的两条不同的消息，因此它也已经不安全了。
>
> MD4和MD5中的MD是消息摘要（Message Digest）的缩写。

## 2. Go中使用MD5

### - 需要导入的包

```go
import (
	"crypto/md5"
	"encoding/hex"
)
```

### - 计算Md5的方式1


```go
func getMD5_1(str []byte) string {
	// 1. 计算数据的md5
	result := md5.Sum(str)
	fmt.Println(result)
	fmt.Printf("%x\n", result)
	// 2. 数据格式化为16进制格式字符串
	res := fmt.Sprintf("%x", result)
	fmt.Println(res)
	// --- 这是另外一种格式化切片的方式
	res = hex.EncodeToString(result[:])
	fmt.Println("res: ", res)
	return  res
}
```

### - 重要函数说明

1. 返回数据data的MD5校验和 

   ```go
   函数所属的包: "crypto/md5"
   func Sum(data []byte) [Size]byte
       - 参数 data: 原始数据
       - 返回值: 经过md5计算之后得到的数据, 长度为 16字节(byte)
   ```

2. 将字符串编码为16进制格式

   ```go
   函数所属的包: "encoding/hex"
   func EncodeToString(src []byte) string
       - 参数 src: 要转换的数据
       - 返回值: 转换之后得到的16进制格式字符串
   ```

### - 计算Md5的方式2

```go
func getMD5_2(str []byte) string {
	// 1. 创建一个使用MD5校验的Hash对象`
	myHash := md5.New()
	// 2. 通过io操作将数据写入hash对象中
	io.WriteString(myHash, "hello")
	//io.WriteString(myHash, ", world")
	myHash.Write([]byte(", world"))
	// 3. 计算结果
	result := myHash.Sum(nil)
	fmt.Println(result)
	// 4. 将结果转换为16进制格式字符串
	res := fmt.Sprintf("%x", result)
	fmt.Println(res)
	// --- 这是另外一种格式化切片的方式
	res = hex.EncodeToString(result)
	fmt.Println(res)

	return res
}
```

### - 重要函数说明

1. 创建一个新的使用MD5校验的hash.Hash接口 

   ```go
   函数所属的包: "crypto/md5"
   func New() hash.Hash
   ```

   Hash是一个被所有hash函数实现的公共接口。 

   ```go
   type Hash interface {
       // 通过嵌入的匿名io.Writer接口的Write方法向hash中添加更多数据，永远不返回错误
       io.Writer
       // 返回添加b到当前的hash值后的新切片，不会改变底层的hash状态
       Sum(b []byte) []byte
       // 重设hash为无数据输入的状态
       Reset()
       // 返回Sum会返回的切片的长度
       Size() int
       // 返回hash底层的块大小；Write方法可以接受任何大小的数据，
       // 但提供的数据是块大小的倍数时效率更高
       BlockSize() int
   }
   
   "io" 包中 Writer 接口用于包装基本的写入方法。
   type Writer interface {
       Write(p []byte) (n int, err error)
   }
   ```

2. 通过io操作将数据写入hash对象中

   ```go
   # 第一种方式
   函数所属的包: "io"
   func WriteString(w Writer, s string) (n int, err error)
       - 参数 w: 实现了/包含Writer接口的对象
       - 参数 s: 要添加到IO对象中的数据
       - 返回值 n: 数据长度
       - 返回值 err: 错误信息
   # 第二种方式
   使用md5包中的New()方法得到的hash.Hash接口(假设名为: myHash)添加数据
   myHash.Write([]byte("测试数据"))
   ```

3. 使用hash.Hash接口中的Sum方法计算结果

   ```go
   Sum(b []byte) []byte
       - 参数 b: 将b中的数据进行哈希计算, 结果添加到原始数据的前面, 
         		 一般情况下该参数指定为空, 即: nil
       - 返回值: 进行哈希运算之后得到的结果 
   ```

## 3. 其他哈希函数（sha256等）

### - 常见哈希函数

- SHA-1
- SHA-224
- ==SHA-256==
- SHA-384
- SHA-512

> SHA-1是由NIST（NationalInstituteOfStandardsandTechnology，美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单向散列函数。1993年被作为美国联邦信息处理标准规格（FIPS PUB 180）发布的是SHA,1995年发布的修订版FIPS PUB 180-1称为SHA-1。
>
> SHA-1的消息长度存在上限，但这个值接近于2^64^比特，是个非常巨大的数值，因此在实际应用中没有问题。
>
> SHA-256、SHA-384和SHA-512都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特、384比特和512比特。这些单向散列函数合起来统称SHA-2，它们的消息长度也存在上限（SHA-256的上限接近于 2^64^ 比特，SHA-384 和 SHA-512的上限接近于 2^128^ 比特）。这些单向散列函数是于2002年和 SHA-1 一起作为 FIPS PUB 180-2发布的 SHA-1 的强抗碰撞性已于2005年被攻破, 也就是说，现在已经能够产生具备相同散列值的两条不同的消息。不过，SHA-2还尚未被攻破。

|         | 比特数 | 字节数 |
| ------- | :----: | :----: |
| MD4     | 128bit | 16byte |
| MD5     | 128bit | 16byte |
| SHA-1   | 160bit | 20byte |
| SHA-224 | 224bit | 28byte |
| SHA-256 | 256bit | 32byte |
| SHA-384 | 384bit | 48byte |
| SHA-512 | 512bit | 64byte |

## 4. Go中对SHA-1、SHA-2的使用

### - 需要导入的包

```go
import (
	"crypto/sha1"
	"encoding/hex"
    "crypto/sha256"
    "crypto/sha512"
)
```

### - 使用sha1计算文件指纹

> 上一小节介绍了如何使用go提供的API计算数据的md5指纹, sha1的计算方式和md5的套路是一样的, 需要将md5包, 替换为sh1, 下面给大家介绍一下如何使用sha1计算文件的指纹(md5亦如此) 

```go
func getSha1(src string) string {
	// 1. 打开文件
	fp, err := os.Open(src)
	if err != nil {
		return "文件打开失败"
	}
	// 2. 创建基于sha1算法的Hash对象
	myHash := sha1.New()
	// 3. 将文件数据拷贝给哈希对象
	num, err := io.Copy(myHash, fp)
	if err != nil {
		return "拷贝文件失败"
	}
	fmt.Println("文件大小: ", num)
	// 4. 计算文件的哈希值
	tmp1 := myHash.Sum(nil)
	// 5. 数据格式转换
    result := hex.EncodeToString(tmp1)
	fmt.Println("sha1: ", result)

	return result
}
```

